use crate::ast::{DataType, Ident};

#[derive(Debug, Clone, Copy)]
pub enum SQL {
    MSAccess,
    LibreOfficeBase,
    MySQL,
    PostgreSQL,
    MSSQL,
}

impl SQL {
    pub fn from_str(s: &str) -> Option<Self> {
        match s {
            "ms_access" => Some(Self::MSAccess),
            "libre_office_base" => Some(Self::LibreOfficeBase),
            "mysql" => Some(Self::MySQL),
            "postgresql" => Some(Self::PostgreSQL),
            "mssql" => Some(Self::MSSQL),
            _ => None,
        }
    }
}

// The methods needed for SQL creation
impl SQL {
    pub fn to_additional_definitions(&self, data_type: &DataType) -> Option<String> {
        match self {
            Self::MSAccess => ms_access::to_additional_definitions(data_type),
            Self::LibreOfficeBase => libre_office_base::to_additional_definitions(data_type),
            Self::MySQL => mysql::to_additional_definitions(data_type),
            Self::PostgreSQL => postgresql::to_additional_definitions(data_type),
            Self::MSSQL => mssql::to_additional_definitions(data_type),
        }
    }

    pub fn to_data_type(&self, data_type: &DataType) -> String {
        match self {
            Self::MSAccess => ms_access::to_data_type(data_type),
            Self::LibreOfficeBase => libre_office_base::to_data_type(data_type),
            Self::MySQL => mysql::to_data_type(data_type),
            Self::PostgreSQL => postgresql::to_data_type(data_type),
            Self::MSSQL => mssql::to_data_type(data_type),
        }
    }

    pub fn to_column_ident(&self, ident: &Ident) -> String {
        match self {
            Self::MSAccess => ms_access::to_column_ident(ident),
            Self::LibreOfficeBase => libre_office_base::to_column_ident(ident),
            Self::MySQL => mysql::to_column_ident(ident),
            Self::PostgreSQL => postgresql::to_column_ident(ident),
            Self::MSSQL => mssql::to_column_ident(ident),
        }
    }
}

mod ms_access {
    use crate::ast::{DataType, Ident};

    use super::MaxLength;

    pub fn to_additional_definitions(data_type: &DataType) -> Option<String> {
        match data_type {
            DataType::Enum(_) => None,
            DataType::Integer
            | DataType::SmallInteger
            | DataType::AutoIncrement
            | DataType::Float
            | DataType::Boolean
            | DataType::Date
            | DataType::Time
            | DataType::DateTime
            | DataType::Varchar(_)
            | DataType::Varbinary(_)
            | DataType::Blob
            | DataType::Text
            | DataType::Uuid
            | DataType::Decimal(_, _) => None,
        }
    }

    pub fn to_data_type(data_type: &DataType) -> String {
        match data_type {
            DataType::Integer => "INTEGER".to_string(),
            DataType::SmallInteger => "INTEGER".to_string(), // TODO
            DataType::AutoIncrement => "AUTOINCREMENT".to_string(),
            DataType::Float => "FLOAT".to_string(),
            DataType::Boolean => "YESNO".to_string(),
            DataType::Date => "DATE".to_string(),
            DataType::Time => "TIME".to_string(),
            DataType::DateTime => "DATETIME".to_string(),
            DataType::Varchar(n) => format!("VARCHAR({})", n),

            DataType::Varbinary(n) => format!("VARBINARY({n})"),
            DataType::Blob => "LONGBINARY".to_string(),
            DataType::Text => "TEXT".to_string(),
            DataType::Uuid => "GUID".to_string(),
            DataType::Decimal(m, d) => format!("DECIMAL({m}, {d})"),
            DataType::Enum(options) => format!("VARCHAR({})", options.max_length().unwrap()),
            // TODO CHECK (mycol IN('a', 'b'))
        }
    }
    pub fn to_column_ident(ident: &Ident) -> String {
        format!("[{}]", ident.to_string())
    }
}

mod libre_office_base {
    use crate::ast::{DataType, Ident};

    use super::MaxLength;

    pub fn to_additional_definitions(data_type: &DataType) -> Option<String> {
        match data_type {
            DataType::Enum(_) => None,
            DataType::Integer
            | DataType::SmallInteger
            | DataType::AutoIncrement
            | DataType::Float
            | DataType::Boolean
            | DataType::Date
            | DataType::Time
            | DataType::DateTime
            | DataType::Varchar(_)
            | DataType::Varbinary(_)
            | DataType::Blob
            | DataType::Text
            | DataType::Uuid
            | DataType::Decimal(_, _) => None,
        }
    }

    // See http://www.hsqldb.org/doc/1.8/guide/guide.html#datatypes-section
    pub fn to_data_type(data_type: &DataType) -> String {
        match data_type {
            DataType::Integer => "INTEGER".to_string(),
            DataType::SmallInteger => "INTEGER".to_string(), // TODO
            DataType::AutoIncrement => "INTEGER GENERATED BY DEFAULT AS IDENTITY".to_string(),
            DataType::Float => "FLOAT".to_string(),
            DataType::Boolean => "BOOLEAN".to_string(),
            DataType::Date => "DATE".to_string(),
            DataType::Time => "TIME".to_string(),
            DataType::DateTime => "DATETIME".to_string(),
            DataType::Varchar(n) => format!("VARCHAR({})", n),

            DataType::Varbinary(n) => format!("VARBINARY({n})"),
            DataType::Blob => "BLOB".to_string(),
            DataType::Text => "LONGVARCHAR".to_string(),
            DataType::Uuid => "UUID".to_string(),
            DataType::Decimal(m, d) => format!("DECIMAL({m}, {d})"),
            DataType::Enum(options) => format!("VARCHAR({})", options.max_length().unwrap()),
            // TODO CHECK (mycol IN('a', 'b'))?
        }
    }
    pub fn to_column_ident(ident: &Ident) -> String {
        ident.to_string()
    }
}

mod mysql {
    use crate::ast::{DataType, Ident};

    pub fn to_additional_definitions(data_type: &DataType) -> Option<String> {
        match data_type {
            DataType::Enum(_) => None,
            DataType::Integer
            | DataType::SmallInteger
            | DataType::AutoIncrement
            | DataType::Float
            | DataType::Boolean
            | DataType::Date
            | DataType::Time
            | DataType::DateTime
            | DataType::Varchar(_)
            | DataType::Varbinary(_)
            | DataType::Blob
            | DataType::Text
            | DataType::Uuid
            | DataType::Decimal(_, _) => None,
        }
    }

    pub fn to_data_type(data_type: &DataType) -> String {
        match data_type {
            DataType::Integer => "INTEGER".to_string(),
            DataType::SmallInteger => "SMALLINT".to_string(),
            DataType::AutoIncrement => "INTEGER AUTO_INCREMENT".to_string(),
            DataType::Float => "FLOAT".to_string(),
            DataType::Boolean => "BOOLEAN".to_string(),
            DataType::Date => "DATE".to_string(),
            DataType::Time => "TIME".to_string(),
            DataType::DateTime => "DATETIME".to_string(),
            DataType::Varchar(n) => format!("VARCHAR({})", n),
            DataType::Varbinary(n) => format!("VARBINARY({n})"),
            DataType::Blob => "BLOB".to_string(),
            DataType::Text => "TEXT".to_string(),
            DataType::Uuid => "UUID".to_string(),
            DataType::Decimal(m, d) => format!("DECIMAL({m}, {d})"),
            DataType::Enum(options) => format!(
                "ENUM({})",
                options
                    .iter()
                    .map(|x| format!("'{}'", x.replace("'", "\'")))
                    .collect::<Vec<_>>()
                    .join(",")
            ),
        }
    }
    pub fn to_column_ident(ident: &Ident) -> String {
        format!("`{}`", ident.to_string())
    }
}

mod postgresql {
    use crate::ast::{DataType, Ident};
    use std::{collections::HashMap, sync::Mutex};

    lazy_static::lazy_static! {
      static ref ENUM_IDX: Mutex<HashMap<Vec<String>, usize>> = Mutex::new(HashMap::new());
    }

    fn get_enum_name(options: &Vec<String>) -> String {
        let mut map = ENUM_IDX.lock().unwrap();

        let idx = if let Some(x) = map.get(options) {
            *x
        } else {
            let new = map.len();
            map.insert(options.clone(), new);
            new
        };

        format!("enum{}", idx)
    }

    pub fn to_additional_definitions(data_type: &DataType) -> Option<String> {
        match data_type {
            // TODO name and enum
            DataType::Enum(options) => Some(format!(
                "CREATE TYPE {} AS ENUM ({});",
                get_enum_name(options),
                options
                    .iter()
                    .map(|x| format!("'{}'", x.replace("'", "\'")))
                    .collect::<Vec<_>>()
                    .join(",")
            )),
            DataType::Integer
            | DataType::SmallInteger
            | DataType::AutoIncrement
            | DataType::Float
            | DataType::Boolean
            | DataType::Date
            | DataType::Time
            | DataType::DateTime
            | DataType::Varchar(_)
            | DataType::Varbinary(_)
            | DataType::Blob
            | DataType::Text
            | DataType::Uuid
            | DataType::Decimal(_, _) => None,
        }
    }

    pub fn to_data_type(data_type: &DataType) -> String {
        match data_type {
            DataType::Integer => "INTEGER".to_string(),
            DataType::SmallInteger => "SMALLINT".to_string(),
            DataType::AutoIncrement => "SERIAL".to_string(),
            DataType::Float => "FLOAT".to_string(),
            DataType::Boolean => "BOOLEAN".to_string(),
            DataType::Date => "DATE".to_string(),
            DataType::Time => "TIME".to_string(),
            DataType::DateTime => "DATETIME".to_string(),
            DataType::Varchar(n) => format!("VARCHAR({})", n),
            DataType::Varbinary(n) => format!("VARBIT({n})"),
            DataType::Blob => "BLOB".to_string(),
            DataType::Text => "TEXT".to_string(),
            DataType::Uuid => "UUID".to_string(),
            DataType::Decimal(m, d) => format!("DECIMAL({m}, {d})"),
            DataType::Enum(options) => get_enum_name(options),
        }
    }
    pub fn to_column_ident(ident: &Ident) -> String {
        ident.to_string()
    }
}

mod mssql {
    use crate::ast::{DataType, Ident};

    use super::MaxLength;

    pub fn to_additional_definitions(data_type: &DataType) -> Option<String> {
        match data_type {
            DataType::Enum(_) => None, // TODO?
            DataType::Integer
            | DataType::SmallInteger
            | DataType::AutoIncrement
            | DataType::Float
            | DataType::Boolean
            | DataType::Date
            | DataType::Time
            | DataType::DateTime
            | DataType::Varchar(_)
            | DataType::Varbinary(_)
            | DataType::Blob
            | DataType::Text
            | DataType::Uuid
            | DataType::Decimal(_, _) => None,
        }
    }

    pub fn to_data_type(data_type: &DataType) -> String {
        match data_type {
            DataType::Integer => "INTEGER".to_string(),
            DataType::SmallInteger => "INTEGER".to_string(), // TODO
            DataType::AutoIncrement => "INTEGER IDENTITY(1,1)".to_string(),
            DataType::Float => "FLOAT".to_string(),
            DataType::Boolean => "BOOLEAN".to_string(),
            DataType::Date => "DATE".to_string(),
            DataType::Time => "TIME".to_string(),
            DataType::DateTime => "DATETIME".to_string(),
            DataType::Varchar(n) => format!("NVARCHAR({n})"),
            DataType::Varbinary(n) => format!("VARBINARY({n})"),
            DataType::Blob => "VARBINARY(max)".to_string(),
            DataType::Text => "NVARCHAR(max)".to_string(),
            DataType::Uuid => "UNIQUEIDENTIFIER".to_string(),
            DataType::Decimal(m, d) => format!("DECIMAL({m}, {d})"),
            DataType::Enum(options) => format!("VARCHAR({})", options.max_length().unwrap()),
            // TODO CHECK (mycol IN('a', 'b'))
            // See https://stackoverflow.com/a/1434338
        }
    }
    pub fn to_column_ident(ident: &Ident) -> String {
        ident.to_string()
    }
}

trait MaxLength {
    fn max_length(&self) -> Option<usize>;
}

impl MaxLength for Vec<String> {
    fn max_length(&self) -> Option<usize> {
        self.iter().map(|x| x.len()).max()
    }
}
